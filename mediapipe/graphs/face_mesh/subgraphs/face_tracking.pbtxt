type: "FaceTrackingSubgraph"

input_stream: "IMAGE:input_video"
output_stream: "DETECTIONS:detections"
output_stream: "LANDMARKS:multi_face_landmarks"
output_stream: "IMAGE:output_image"

# Caches face rects calculated from landmarks, and upon the arrival of the next
# input image, sends out the cached rects with timestamps replaced by that of
# the input image, essentially generating a packet that carries the previous
# face rects. Note that upon the arrival of the very first input image, a
# timestamp bound update occurs to jump start the feedback loop.
node {
  calculator: "PreviousLoopbackCalculator"
  input_stream: "MAIN:input_video"
  input_stream: "LOOP:face_presence"
  input_stream_info: {
    tag_index: "LOOP"
    back_edge: true
  }
  output_stream: "PREV_LOOP:prev_face_presence"
}

# Drops the incoming image if FaceLandmarkSubgraph was able to identify face
# presence in the previous image. Otherwise, passes the incoming image through
# to trigger a new round of face detection in faceDetectionSubgraph.
node {
  calculator: "GateCalculator"
  input_stream: "input_video"
  input_stream: "DISALLOW:prev_face_presence"
  output_stream: "face_detection_input_video"

  node_options: {
    [type.googleapis.com/mediapipe.GateCalculatorOptions] {
      empty_packets_as_allow: true
    }
  }
}

# Subgraph that detections faces (see face_detection_gpu.pbtxt).
node {
  calculator: "FaceDetectionSubgraph"
  input_stream: "IMAGE:face_detection_input_video"
  output_stream: "NORM_RECT:face_rect_from_face_detections"
}

# Subgraph that localizes face landmarks (see face_landmark_gpu.pbtxt).
node {
  calculator: "FaceLandmarkSubgraph"
  input_stream: "IMAGE:input_video"
  input_stream: "NORM_RECT:face_rect"
  output_stream: "LANDMARKS:face_landmarks"
  output_stream: "NORM_RECT:face_rect_from_landmarks"
  output_stream: "PRESENCE:face_presence"
}

# Caches a face rectangle fed back frof FaceLandmarkSubgraph, and upon the
# arrival of the next input image sends out the cached rectangle with the
# timestamp replaced by that of the input image, essentially generating a packet
# that carries the previous face rectangle. Note that upon the arrival of the
# very first input image, an empty packet is sent out to jump start the
# feedback loop.
node {
  calculator: "PreviousLoopbackCalculator"
  input_stream: "MAIN:input_video"
  input_stream: "LOOP:face_rect_from_landmarks"
  input_stream_info: {
    tag_index: "LOOP"
    back_edge: true
  }
  output_stream: "PREV_LOOP:prev_face_rect_from_landmarks"
}

# Merges a stream of face rectangles generated by FaceDetectionSubgraph and that
# generated by FaceLandmarkSubgraph into a single output stream by selecting
# between one of the two streams. The former is selected if the incoming packet
# is not empty, i.e., face detection is performed on the current image by
# FaceDetectionSubgraph (because FaceLandmarkSubgraph could not identify face
# presence in the previous image). Otherwise, the latter is selected, which is
# never empty because FaceLandmarkSubgraphs processes all images (that went
# through FlowLimiterCaculator).
node {
  calculator: "MergeCalculator"
  input_stream: "face_rect_from_landmarks"
  input_stream: "prev_face_rect_from_landmarks"
  output_stream: "face_rect"
}
